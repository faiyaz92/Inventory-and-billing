import 'package:equatable/equatable.dart';
import 'package:requirment_gathering_app/taxi/taxi_service_type_model.dart';
import 'package:requirment_gathering_app/taxi/taxi_setting_model.dart';
import 'package:requirment_gathering_app/taxi/taxi_type_model.dart';
import 'package:requirment_gathering_app/taxi/trip_status_model.dart';
import 'package:requirment_gathering_app/taxi/trip_type_model.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:requirment_gathering_app/taxi/taxi_setting_service.dart';

class TaxiSettingsCubit extends Cubit<TaxiSettingsState> {
  final ITaxiSettingsService _service;

  TaxiSettingsCubit(this._service) : super(TaxiSettingsState.initial()) {
    fetchSettings();
  }

  Future<void> fetchSettings() async {
    emit(state.copyWith(isLoading: true));
    try {
      final settings = await _service.getSettings();
      // Assuming the service can provide lists of types/statuses; you may need to extend ITaxiSettingsService
      // For now, we'll fetch only settings as per the existing service
      emit(state.copyWith(
        settings: settings,
        taxiTypes: settings.taxiTypes, // Replace with actual fetch if service supports
        tripTypes: settings.tripTypes,
        serviceTypes: settings.serviceTypes,
        tripStatuses: settings.tripStatuses,
        isLoading: false,
      ));
    } catch (e) {
      emit(state.copyWith(
        isLoading: false,
        errorMessage: "Failed to load settings: $e",
      ));
    }
  }

  Future<void> addTaxiType(String name, BuildContext context) async {
    if (state.taxiTypes.any((type) => type.name.toLowerCase() == name.toLowerCase())) {
      _showSnackbar(context, "Taxi Type '$name' already exists.");
      return;
    }
    try {
      await _service.addTaxiType(TaxiType(
        id: '', // ID will be generated by the repository
        name: name,
        createdAt: DateTime.now(),
        createdBy: 'admin', // Replace with actual user from AccountRepository
      ));
      await fetchSettings();
    } catch (e) {
      emit(state.copyWith(errorMessage: "Failed to add taxi type: $e"));
    }
  }

  Future<void> editTaxiType(String oldName, String newName, BuildContext context) async {
    if (state.taxiTypes.any((type) => type.name.toLowerCase() == newName.toLowerCase())) {
      _showSnackbar(context, "Taxi Type '$newName' already exists.");
      return;
    }
    try {
      final taxiType = state.taxiTypes.firstWhere((type) => type.name == oldName);
      await _service.deleteTaxiType(taxiType.id);
      await _service.addTaxiType(taxiType.copyWith(name: newName));
      await fetchSettings();
    } catch (e) {
      emit(state.copyWith(errorMessage: "Failed to edit taxi type: $e"));
    }
  }

  Future<void> deleteTaxiType(String id) async {
    try {
      await _service.deleteTaxiType(id);
      await fetchSettings();
    } catch (e) {
      emit(state.copyWith(errorMessage: "Failed to delete taxi type: $e"));
    }
  }

  Future<void> addTripType(String name, BuildContext context) async {
    if (state.tripTypes.any((type) => type.name.toLowerCase() == name.toLowerCase())) {
      _showSnackbar(context, "Trip Type '$name' already exists.");
      return;
    }
    try {
      await _service.addTripType(TripType(
        id: '',
        name: name,
        createdAt: DateTime.now(),
        createdBy: 'admin',
      ));
      await fetchSettings();
    } catch (e) {
      emit(state.copyWith(errorMessage: "Failed to add trip type: $e"));
    }
  }

  Future<void> editTripType(String oldName, String newName, BuildContext context) async {
    if (state.tripTypes.any((type) => type.name.toLowerCase() == newName.toLowerCase())) {
      _showSnackbar(context, "Trip Type '$newName' already exists.");
      return;
    }
    try {
      final tripType = state.tripTypes.firstWhere((type) => type.name == oldName);
      await _service.deleteTripType(tripType.id);
      await _service.addTripType(tripType.copyWith(name: newName));
      await fetchSettings();
    } catch (e) {
      emit(state.copyWith(errorMessage: "Failed to edit trip type: $e"));
    }
  }

  Future<void> deleteTripType(String id) async {
    try {
      await _service.deleteTripType(id);
      await fetchSettings();
    } catch (e) {
      emit(state.copyWith(errorMessage: "Failed to delete trip type: $e"));
    }
  }

  Future<void> addServiceType(String name, BuildContext context) async {
    if (state.serviceTypes.any((type) => type.name.toLowerCase() == name.toLowerCase())) {
      _showSnackbar(context, "Service Type '$name' already exists.");
      return;
    }
    try {
      await _service.addServiceType(ServiceType(
        id: '',
        name: name,
        createdAt: DateTime.now(),
        createdBy: 'admin',
      ));
      await fetchSettings();
    } catch (e) {
      emit(state.copyWith(errorMessage: "Failed to add service type: $e"));
    }
  }

  Future<void> editServiceType(String oldName, String newName, BuildContext context) async {
    if (state.serviceTypes.any((type) => type.name.toLowerCase() == newName.toLowerCase())) {
      _showSnackbar(context, "Service Type '$newName' already exists.");
      return;
    }
    try {
      final serviceType = state.serviceTypes.firstWhere((type) => type.name == oldName);
      await _service.deleteServiceType(serviceType.id);
      await _service.addServiceType(serviceType.copyWith(name: newName));
      await fetchSettings();
    } catch (e) {
      emit(state.copyWith(errorMessage: "Failed to edit service type: $e"));
    }
  }

  Future<void> deleteServiceType(String id) async {
    try {
      await _service.deleteServiceType(id);
      await fetchSettings();
    } catch (e) {
      emit(state.copyWith(errorMessage: "Failed to delete service type: $e"));
    }
  }

  Future<void> addTripStatus(String name, BuildContext context) async {
    if (state.tripStatuses.any((status) => status.name.toLowerCase() == name.toLowerCase())) {
      _showSnackbar(context, "Trip Status '$name' already exists.");
      return;
    }
    try {
      await _service.addTripStatus(TripStatus(
        id: '',
        name: name,
        createdAt: DateTime.now(),
        createdBy: 'admin',
      ));
      await fetchSettings();
    } catch (e) {
      emit(state.copyWith(errorMessage: "Failed to add trip status: $e"));
    }
  }

  Future<void> editTripStatus(String oldName, String newName, BuildContext context) async {
    if (state.tripStatuses.any((status) => status.name.toLowerCase() == newName.toLowerCase())) {
      _showSnackbar(context, "Trip Status '$newName' already exists.");
      return;
    }
    try {
      final tripStatus = state.tripStatuses.firstWhere((status) => status.name == oldName);
      await _service.deleteTripStatus(tripStatus.id);
      await _service.addTripStatus(tripStatus.copyWith(name: newName));
      await fetchSettings();
    } catch (e) {
      emit(state.copyWith(errorMessage: "Failed to edit trip status: $e"));
    }
  }

  Future<void> deleteTripStatus(String id) async {
    try {
      await _service.deleteTripStatus(id);
      await fetchSettings();
    } catch (e) {
      emit(state.copyWith(errorMessage: "Failed to delete trip status: $e"));
    }
  }

  Future<void> updateSettings(TaxiSettings settings, BuildContext context) async {
    emit(state.copyWith(isSaving: true));
    try {
      await _service.updateSettings(settings);
      emit(state.copyWith(settings: settings, isSaving: false));
      _showSnackbar(context, "Settings updated successfully.");
    } catch (e) {
      emit(state.copyWith(
        isSaving: false,
        errorMessage: "Failed to update settings: $e",
      ));
    }
  }

  void _showSnackbar(BuildContext context, String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text(message)),
    );
  }
}
class TaxiSettingsState extends Equatable {
  final TaxiSettings settings;
  final List<TaxiType> taxiTypes;
  final List<TripType> tripTypes;
  final List<ServiceType> serviceTypes;
  final List<TripStatus> tripStatuses;
  final bool isLoading;
  final bool isSaving;
  final String? errorMessage;

  const TaxiSettingsState({
    required this.settings,
    required this.taxiTypes,
    required this.tripTypes,
    required this.serviceTypes,
    required this.tripStatuses,
    this.isLoading = false,
    this.isSaving = false,
    this.errorMessage,
  });

  factory TaxiSettingsState.initial() {
    return TaxiSettingsState(
      settings: TaxiSettings(
        perKmFareRate: 0.0,
        minimumFare: 0.0,
        whatsappNotificationFareThreshold: 0.0,
        updatedAt: DateTime.now(),
        updatedBy: '',
        taxiTypes: [],
        tripTypes: [],
        serviceTypes: [],
        tripStatuses: [],
      ),
      isLoading: false,
      isSaving: false,
      errorMessage: null,
      taxiTypes: const [],
      tripTypes: const [],
      serviceTypes: const [],
      tripStatuses: const [],
    );
  }

  TaxiSettingsState copyWith({
    TaxiSettings? settings,
    List<TaxiType>? taxiTypes,
    List<TripType>? tripTypes,
    List<ServiceType>? serviceTypes,
    List<TripStatus>? tripStatuses,
    bool? isLoading,
    bool? isSaving,
    String? errorMessage,
  }) {
    return TaxiSettingsState(
      settings: settings ?? this.settings,
      taxiTypes: taxiTypes ?? this.taxiTypes,
      tripTypes: tripTypes ?? this.tripTypes,
      serviceTypes: serviceTypes ?? this.serviceTypes,
      tripStatuses: tripStatuses ?? this.tripStatuses,
      isLoading: isLoading ?? this.isLoading,
      isSaving: isSaving ?? this.isSaving,
      errorMessage: errorMessage,
    );
  }

  @override
  List<Object?> get props => [
        settings,
        taxiTypes,
        tripTypes,
        serviceTypes,
        tripStatuses,
        isLoading,
        isSaving,
        errorMessage,
      ];
}
